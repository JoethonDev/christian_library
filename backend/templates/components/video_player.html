<!-- templates/components/video_player.html -->
{% load i18n %}
{% if video.videometa %}
    <div id="video-player-container">
        <!-- 
            FIX 1: Use CSS aspect ratio hack instead of Bootstrap .ratio class for better compatibility.
            This outer container enforces the 16:9 aspect ratio and prevents the black bars.
        -->
        <div class="video-wrapper" style="padding-bottom: 56.25%; height: 0; border-radius:1rem; overflow:hidden; background:#000;">
            
            <!-- Quality Selector Overlay -->
            {% if available_qualities and available_qualities|length > 1 %}
                <div style="position:absolute; top:10px; right:10px; z-index:1000;">
                    <!-- Quality selector HTML is simplified to rely purely on JS/hls.js -->
                    <select id="quality-select" name="quality" class="form-select form-select-sm" 
                            style="background: rgba(0,0,0,0.85); border: 1px solid rgba(255,255,255,0.3); color: white; font-size: 0.8rem; min-width: 70px; padding: 2px 6px;">
                        <!-- 'auto' corresponds to HLS ABR (Adaptive Bitrate) -->
                        <option value="auto" {% if selected_quality == 'auto' %}selected{% endif %}>{% trans "Auto" %}</option>
                        {% for q in available_qualities %}
                            <option value="{{ q }}" {% if selected_quality == q %}selected{% endif %}>{{ q|upper }}</option>
                        {% endfor %}
                    </select>
                </div>
            {% endif %}
            
            <!-- 
                FIX 2: Ensure video element fills the entire space of the aspect ratio container.
                It needs position:absolute, top:0, left:0, and 100% height/width.
            -->
            <video id="video-{{ video.id }}" controls preload="metadata" 
                   style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display:block;"
                   poster="{% if video.videometa.thumbnail %}{{ video.videometa.thumbnail.url }}{% endif %}">
                {% if hls_playlist %}
                    <!-- HLS streaming source -->
                    <source src="{% url 'core_utils:secure_stream' file_path=hls_playlist %}" type="application/vnd.apple.mpegurl">
                {% elif video.videometa.original_file %}
                    <!-- Fallback -->
                    <source src="{% url 'core_utils:secure_stream' file_path=video.videometa.original_file %}" type="video/mp4">
                    <source src="{% url 'core_utils:secure_stream' file_path=video.videometa.original_file %}" type="video/webm">
                {% endif %}
                {% trans "Your browser does not support the video element." %}
            </video>
        </div>
    </div>
    <script>
    function initializeVideoPlayer() {
        const video = document.getElementById('video-{{ video.id }}');
        const videoSrc = video.querySelector('source[type="application/vnd.apple.mpegurl"]');
        const qualitySelect = document.getElementById('quality-select');
        
        let hlsInstance = null;
        
        console.log('Video player loaded.', {
            selectedQuality: '{{ selected_quality }}',
            hlsPlaylist: '{{ hls_playlist }}'
        });
        
        if (videoSrc && typeof Hls !== 'undefined') {
            if (Hls.isSupported()) {
                const hls = new Hls({
                    enableWorker: true,
                    lowLatencyMode: false,
                    backBufferLength: 90,
                    maxBufferLength: 300,
                    maxMaxBufferLength: 600,
                    manifestLoadingTimeOut: 20000,
                    manifestLoadingMaxRetry: 3,
                    manifestLoadingRetryDelay: 1000,
                    levelLoadingTimeOut: 20000,
                    levelLoadingMaxRetry: 3,
                    levelLoadingRetryDelay: 1000,
                    fragLoadingTimeOut: 20000,
                    fragLoadingMaxRetry: 3,
                    fragLoadingRetryDelay: 1000,
                    startLevel: -1, 
                    abrEwmaDefaultEstimate: 500000
                });
                
                hlsInstance = hls;
                
                console.log('Loading HLS source:', videoSrc.src);
                hls.loadSource(videoSrc.src);
                hls.attachMedia(video);
                
                hls.on(Hls.Events.MANIFEST_PARSED, function(event, data) {
                    console.log('HLS manifest parsed:', data);
                    console.log('Available levels:', data.levels);
                    
                    // More detailed level logging
                    data.levels.forEach((level, index) => {
                        console.log(`Level ${index}:`, {
                            width: level.width,
                            height: level.height,
                            bitrate: level.bitrate,
                            name: level.name,
                            url: level.url
                        });
                    });
                    
                    const levelLabels = data.levels.map(l => {
                        // Try multiple ways to get resolution
                        if (l.height && l.height > 0) {
                            return l.height + 'p';
                        } else if (l.name) {
                            return l.name;
                        } else if (l.url) {
                            // Try to extract resolution from URL
                            const urlMatch = l.url.match(/(\d+)p/);
                            return urlMatch ? urlMatch[0] : 'Unknown';
                        }
                        return 'Level ' + data.levels.indexOf(l);
                    });
                    
                    console.log('HLS manifest loaded, levels:', levelLabels);
                    
                    if ('{{ selected_quality }}' !== 'auto' && hls.levels.length > 0) {
                        const initialQuality = '{{ selected_quality }}'.toUpperCase();
                        
                        // Try multiple matching strategies
                        let targetLevel = -1;
                        
                        // Strategy 1: Match by height
                        targetLevel = hls.levels.findIndex(l => (l.height + 'P') === initialQuality);
                        
                        // Strategy 2: Match by name
                        if (targetLevel === -1) {
                            targetLevel = hls.levels.findIndex(l => l.name && l.name.toUpperCase() === initialQuality);
                        }
                        
                        // Strategy 3: Match by URL pattern
                        if (targetLevel === -1) {
                            targetLevel = hls.levels.findIndex(l => l.url && l.url.includes(initialQuality.toLowerCase()));
                        }
                        
                        if (targetLevel !== -1) {
                            hls.currentLevel = targetLevel;
                            console.log('Set initial HLS level to:', targetLevel, 'for quality:', initialQuality);
                        } else {
                            console.warn('Initial quality not found:', initialQuality, 'Available levels:', levelLabels);
                        }
                    }
                });

                if (qualitySelect) {
                    qualitySelect.addEventListener('change', function(e) {
                        const selectedQuality = this.value;
                        console.log('Quality changed to:', selectedQuality);

                        if (selectedQuality === 'auto') {
                            hls.currentLevel = -1; // ABR
                            console.log('Switched to Automatic Quality (ABR)');
                        } else if (hls.levels && hls.levels.length > 0) {
                            const targetQuality = selectedQuality.toUpperCase();
                            let targetLevel = -1;
                            
                            // Strategy 1: Match by height
                            targetLevel = hls.levels.findIndex(l => (l.height + 'P') === targetQuality);
                            
                            // Strategy 2: Match by name
                            if (targetLevel === -1) {
                                targetLevel = hls.levels.findIndex(l => l.name && l.name.toUpperCase() === targetQuality);
                            }
                            
                            // Strategy 3: Match by URL pattern
                            if (targetLevel === -1) {
                                targetLevel = hls.levels.findIndex(l => l.url && l.url.includes(targetQuality.toLowerCase()));
                            }
                            
                            if (targetLevel !== -1) {
                                hls.currentLevel = targetLevel;
                                console.log('Manually set HLS level to:', targetLevel, `(${targetQuality})`);
                            } else {
                                console.error('Target quality level not found in HLS manifest:', selectedQuality);
                                console.log('Available levels:', hls.levels.map((l, i) => ({
                                    index: i,
                                    height: l.height,
                                    name: l.name,
                                    url: l.url
                                })));
                            }
                        }
                    });
                }
                
                hls.on(Hls.Events.ERROR, function(event, data) {
                    console.error('HLS error:', data);
                    // Check for fatal errors and attempt recovery
                    if (data.fatal) {
                        switch(data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                console.warn('HLS network error, attempting recovery...');
                                hls.startLoad();
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                console.warn('HLS media error, attempting recovery...');
                                hls.recoverMediaError();
                                break;
                            default:
                                console.error('HLS fatal error:', data);
                                hls.destroy();
                                break;
                        }
                    }
                });
            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                console.log('Using native HLS support');
                video.src = videoSrc.src;
                if (qualitySelect) {
                    qualitySelect.disabled = true;
                }
            }
        } else {
            console.log('HLS not available, using direct video source');
        }
        
        return hlsInstance;
    }
    
    // Initialize the video player immediately
    initializeVideoPlayer();
    </script>
    
    <style>
    /* Quality selector styling */
    #quality-select {
        transition: all 0.2s ease;
        backdrop-filter: blur(8px);
        border-radius: 6px !important;
        font-weight: 500;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    
    #quality-select:hover {
        background: rgba(0,0,0,0.95) !important;
        border-color: rgba(255,255,255,0.5) !important;
        transform: scale(1.02);
    }
    
    #quality-select:focus {
        background: rgba(0,0,0,0.95) !important;
        border-color: #87CEEB !important;
        box-shadow: 0 0 0 2px rgba(135, 206, 235, 0.3) !important;
        outline: none;
    }
    
    #quality-select option {
        background: #222;
        color: white;
        padding: 4px;
    }
    </style>
{% else %}
    <div class="ratio ratio-16x9 w-100 d-flex align-items-center justify-content-center" style="background: #f8f9fa; min-height:60vh;">
        <div class="text-center w-100">
            <div class="mb-3">
                <i class="bi bi-exclamation-triangle text-warning" style="font-size: 3rem;"></i>
            </div>
            <h6 class="text-muted mb-2">{% trans "Video file not available" %}</h6>
            <p class="text-muted small mb-0">{% trans "This video has not been uploaded yet" %}</p>
        </div>
    </div>
{% endif %}